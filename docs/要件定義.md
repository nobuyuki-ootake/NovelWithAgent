# 📘 AI 共創型小説作成ツール 要件定義（ブラッシュアップ版）

---

## 1. プロジェクト概要

### 1.1 目的・背景

- AI との本格的な共創による新しい創作体験を提供し、従来のチャットベース支援から脱却する。

### 1.2 ターゲットユーザー

- 作家志望者、創作初心者、現役小説家、教育機関など幅広い層。

### 1.3 想定アウトプット

- 長編／短編小説、プロット案、キャラクター設定集など多様な創作成果物。

---

## 2. 機能要件

### 2.1 AI エージェント・共創モデル

- 必要な AI エージェントの役割：
  - プロット設計者
  - キャラクター開発者
  - 文体校正者
  - アイデアブレインストーミング役
  - 編集者／批評家
- エージェントのカスタマイズ性：ユーザーが役割や性格を設定可能。
- インタラクション形式：チャット UI を基本とし、将来的にエージェント同士の議論も検討。

### 2.2 小説作成支援機能

- サポートする創作プロセス：
  - プロット構成、キャラクター設定、世界観構築、章構成、テーマ調整、推敲・リライト支援
- データ管理形式：創作プロセスごとに JSON で管理し、再利用やバージョン管理を容易に。
- 文章改善・校正機能：必要（AI による提案・校正サポートを実装）。

### 2.3 提案・対話設計

- 提案タイミング：ユーザー操作（ボタンやドラッグ）で箇所指定、または全体構成時。
- 提案表示形式：選択式＋インライン挿入。将来的に履歴・比較機能も実装。

---

## 3. UI/UX 要件

### 3.1 エディタ・インターフェース

- 本文編集 UI：
  - メインペイン(中央)であり、独自エディタ（日本語小説向け、400 字縦書き方眼紙風）を採用。
- 補助情報（プロット・人物・設定）：メインペインの内容切り替えを行うメニュー(左ペイン)。
- エージェント対話表示：分割ビューで同時進行可能。

### 3.1.1 補助情報ペイン内容

1. あらすじ
2. プロット
3. キャラクター
4. 世界観構築
5. タイムライン
6. 本文執筆
   6.1 章
7. 読者想定リアクション/エージェントによる総評

### 3.1.2 メインペイン内容

本文執筆時:

- 独自エディタ（日本語小説向け、400 字縦書き方眼紙風）
  上記以外の場合は、横書きのテキストエディタとする

### 3.2 ユーザー体験設計

- 想定創作スタイル：ゼロからの創作を主軸とし、今後コラボや既存案改良も検討。
- 共創の価値：AI 活用で矛盾の少ない構成や、読者視点のフィードバックを得られる。
- 作風・ジャンル変更 UI：途中変更は非対応。新規作成を推奨。

### 3.3 UI 詳細

- パネル構成：
  1. 工程切り替えリスト
  2. 執筆内容表示（工程フロー式）
  3. AI 対話パネル（収納可）

---

## 4. 技術的要件

### 4.1 システム構成

- 使用 AI モデル：ChatGPT または Claude を想定。
- 外部 API・連携：
  - 画像生成（Midjourney, DALL·E 等／初期リリース除外）
  - テキスト保存・バージョン管理（Firebase, Git 等／JSON 形式）
  - クラウド保存（Google Drive, Notion 等／将来検討）
- 対応デバイス：Web UI（Windows, mac 対応）
- 開発環境：
  - フロントエンド：React + TypeScript
  - 状態管理：Recoil
  - UI: Material-UI
  - テスト・開発支援：Storybook
- **データベース：RDS（PostgreSQL/MySQL 等の RDB）を正式採用**
  - ユーザー・トークン・API キーは RDB で管理
  - API キーは暗号化して保存
  - トークンには有効期限（例：30 日）を持たせる
- **キャッシュ：Redis**（API レスポンス等の一時キャッシュ用途）

### 4.2 データモデル

#### 4.2.1 ユーザー・トークン・API キー管理（RDB）

- `user_tokens` テーブル
  - user_id, token, expires_at, created_at
- `user_api_keys` テーブル
  - user_id, provider, api_key（暗号化）, created_at, updated_at

#### 4.2.2 プロジェクト構造

- `NovelProject`: 小説プロジェクト全体を表す
  - id, title, createdAt, updatedAt, synopsis
  - plot: プロット要素の配列
  - characters: キャラクター情報の配列
  - worldBuilding: 世界観設定
  - timeline: タイムライン上のイベント配列
  - chapters: 章の配列
  - feedback: フィードバック情報の配列

#### 4.2.3 プロット管理

- `PlotItem`: プロットの各項目
  - id, title, description, type, order
  - type: "イベント" | "転機" | "伏線" | "設定"

#### 4.2.4 執筆機能

- `Chapter`: 章情報
  - id, title, content, order
- `RelatedEvent`: 章に関連するイベント
  - id, title, description, chapterId

### 4.3 セキュリティ・著作権

- データ保存：ローカル保存を基本とし、ユーザーの所有権を明確化。
- **API キーは RDB に暗号化して保存**
- **トークンには有効期限（例：30 日）を持たせる**
- トークン検証に合格したユーザーのみ API キー取得・利用が可能
- 著作権方針：ユーザー所有を原則とし、利用条件も明記予定。
- バックアップ・削除：ローカル保存/再生のみ（クラウドは将来検討）。

---

## 5. データ構造

### 5.1. プロジェクトデータ (`NovelProject`)

プロジェクト全体を管理する主要なデータオブジェクト。基本的な小説情報に加え、登場人物、世界観設定、プロット、原稿などを保持する。

```typescript
interface NovelProject {
  id: string;
  title: string;
  author: string;
  genre: string;
  logline?: string;
  storySynopsis?: string;
  // ... (他の小説基本情報)

  characters?: CharacterElement[];
  worldBuilding?: WorldBuildingData; // 世界観設定
  plot?: PlotData;
  manuscripts?: ManuscriptData[];
  // ... (その他プロジェクト関連データ)

  // UI状態や設定など
  currentTab?: string;
  lastEdited?: string;
}

interface WorldBuildingData {
  settingDetails?: string; // 全体的な世界観設定メモ
  characters?: CharacterElement[]; // 世界観に紐づく登場人物（プロジェクト全体の登場人物と重複・関連する可能性あり）
  places?: PlaceElement[]; // 場所・地理情報
  timelineEvents?: TimelineEvent[]; // 歴史・年表
  stateDefinitions?: StateDefinition[]; // 状態定義
  customFields?: CustomWorldBuildingField[]; // カスタム項目
  // ... (その他世界観要素)
}

// PlaceElement の詳細構造は frontend/src/types/index.ts を参照
// CharacterElement, TimelineEvent, StateDefinition, CustomWorldBuildingField も同様
```

(以下、他のデータ構造定義が続く...)

## 7. 状態管理と永続化

### 7.1. クライアントサイド状態管理

フロントエンドにおける状態管理は主に Recoil を使用する。
主要なグローバルステートとして、現在編集中のプロジェクトデータ (`currentProjectState`) を Recoil atom で管理する。
この `currentProjectState` は、アプリケーション全体で共有され、各機能（登場人物編集、世界観構築、プロット作成など）はこのステートを購読・更新する。

### 7.2. データ永続化

ユーザーが作成・編集したプロジェクトデータ (`NovelProject` オブジェクト全体) は、ブラウザの localStorage に保存される。
`currentProjectState` が更新されるたびに、`useHome` フック内の `updateAndSaveCurrentProject` 関数などを通じて、localStorage にシリアライズされたデータが書き込まれる。
アプリケーション起動時には、localStorage からデータが読み込まれ、`currentProjectState` が初期化される。
これにより、ユーザーはブラウザを閉じても作業内容を失うことなく、前回終了時の状態から再開できる。

将来的にはバックエンドサーバーと連携し、クラウドベースでのデータ永続化を検討する。

---

## 8. AI アシスト機能詳細要件

### 8.1 AI アシスト対象画面

以下の全ての画面に AI アシスト機能を実装する：

- あらすじ
- プロット
- キャラクター
- 世界観構築
- タイムライン
- 執筆画面

### 8.2 AI アシスト機能 UI

- **「AI に項目を埋めてもらう」ボタン**:
  - 各画面の適切な位置に配置
  - ボタン押下で、現在の画面の入力項目を AI が自動で生成・入力
  - 生成中は適切なローディングインジケータを表示
  - 生成完了後はユーザーが編集可能な状態で表示

### 8.3 ウォーターフォール型制作フロー

- **データ参照の流れ**:

  - あらすじ作成時: タイトルを参照
  - プロット作成時: タイトル + あらすじを参照
  - キャラクター作成時: タイトル + あらすじ + プロットを参照
  - 世界観構築時: タイトル + あらすじ + プロット + キャラクターを参照
  - タイムライン作成時: 上記すべてを参照
  - 執筆時: 上記すべてを参照

- **コンテキスト引継ぎ**:
  - 上位工程で作成した情報を自動的に下位工程の AI プロンプトに含める
  - 各画面の AI アシスト機能は、それまでに作成された全情報を考慮して提案を生成

### 8.4 AI アシスト実装方針

- **プロンプト構成**:

  - システムプロンプト: 各画面の役割や生成すべき内容の指示
  - コンテキスト: 上位工程で作成された情報
  - ユーザープロンプト: 「AI に項目を埋めてもらう」操作の指示

- **API 連携**:

  - プロキシサーバーを介して AI API と通信
  - 認証情報や API キーはプロキシサーバーで安全に管理
  - レスポンスは JSON 形式で構造化し、フロントエンドでパースして表示

- **エラーハンドリング**:
  - API 接続エラー時の適切なフォールバックとリトライ
  - 生成内容が不適切な場合のユーザーフィードバック機能
  - トークン制限管理（コンテキスト量の自動調整）

### 8.5 AI アシスト機能の拡張性

- 将来的に「一部だけ再生成」機能の追加を検討
- ユーザーの編集履歴をもとにした学習・調整機能
- 複数の生成案を提示し、ユーザーが選択できる機能

---

## 9. AI 連携設定画面

### 9.1 概要

ユーザーが AI 連携の設定を管理するための専用画面を提供します。API キーの設定、使用する AI モデルの選択、プロバイダーの選択などが可能になります。

### 9.2 基本機能

- **AI プロバイダー選択**:

  - OpenAI (GPT-3.5/GPT-4)
  - Anthropic (Claude)
  - Google (Gemini)
  - カスタム API エンドポイント（将来拡張用）

- **API キー管理**:

  - プロバイダーごとの API キー設定
  - API キー暗号化保存（クライアント側で暗号化してサーバーに送信）
  - API キー有効性テスト機能
  - セキュリティ警告（キーの安全な扱いについて）

- **モデル選択**:
  - プロバイダーごとの利用可能なモデル一覧表示
  - モデルのコスト情報表示
  - 推奨モデルの提案
  - モデルの特性説明（得意分野、トークン上限など）

### 9.3 詳細設定

- **モデルパラメータ設定**:

  - 温度（Temperature）
  - 上位確率（Top P）
  - 最大トークン数
  - その他の高度な設定（モデルごとに対応）

- **使用量管理**:

  - 推定使用コスト表示
  - 月間使用量の目安設定
  - 使用量通知の設定

- **フォールバックは行わない！**:
  - リクエスト失敗時はエラー解消に必要な情報を console 出力する
  - 失敗時の再試行設定

### 9.4 UI/UX 要件

- **画面レイアウト**:

  - タブ切り替え式で各プロバイダーの設定を分離
  - API キー入力はパスワードフィールドで保護
  - モデル選択はドロップダウンメニュー形式
  - 設定保存・テストボタンを目立つ位置に配置

- **アクセス制御**:

  - 設定画面へのアクセスはパスワード保護（任意設定）
  - 新規 API キー設定時の確認画面

- **フィードバック表示**:
  - 設定保存成功/失敗の通知
  - API キー有効性テスト結果の表示
  - 設定変更によるコスト変動の表示

### 9.5 セキュリティ要件

- **API キー保護**:

  - クライアント側での暗号化（AES-256）
  - サーバー側での再暗号化保存
  - 表示時はマスキング処理

- **通信セキュリティ**:

  - HTTPS 通信の強制
  - API キー送信時の追加暗号化

- **データ保護**:
  - API キーの保存はセキュアストレージ使用
  - ブラウザキャッシュに API キーを残さない処理

### 9.6 技術実装要件

- **フロントエンド**:

  - フォーム検証（必須項目、形式チェック）
  - 暗号化ライブラリ（crypto-js 等）
  - 設定状態の Recoil 管理

- **バックエンド**:

  - API キー暗号化保存処理
  - キー有効性検証 API
  - プロバイダー連携処理

- **データ構造**:
  - ユーザーごとの AI 設定プロファイル
  - キー情報の暗号化保存スキーマ
